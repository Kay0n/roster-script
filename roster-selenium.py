# Generated by Selenium IDE
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions as condition
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.common.exceptions import NoSuchElementException


class RosterSelenium():

  def setup_driver(self):
    self.driver = webdriver.Firefox()
    self.wait = WebDriverWait(self.driver, 12)
    self.driver.implicitly_wait(12)
    self.vars = {}
  

  def teardown_driver(self):
    self.driver.quit()


  def wait_and_click(self, selector: tuple):
    clickable_element = self.wait.until(condition.element_to_be_clickable(selector))
    clickable_element.click()
  
  def js_click(self, selector: tuple):
    element = self.driver.find_element(selector[0], selector[1])
    self.driver.execute_script("arguments[0].click();", element)

  
  def login(self, user, password):
    self.driver.get("https://kronos.calvarycare.org.au/")
    self.driver.set_window_size(1920, 1048)
    self.driver.find_element(By.ID, "userNameInput").click()
    self.driver.find_element(By.ID, "userNameInput").send_keys(user)
    self.driver.find_element(By.ID, "passwordInput").send_keys(password)
    self.driver.find_element(By.ID, "submitButton").click()
    
  
  def select_schedule_hyperfind(self):
    self.driver.find_element(By.XPATH, "//li[5]/div/div/span[2]").click()
    self.driver.switch_to.frame(1)

    self.js_click((By.ID, "hyperfindIcon"))
    self.js_click((By.XPATH, "//section[2]/header/a/span"))
    self.js_click((By.LINK_TEXT, "CAH-C9430-ICU"))

  
  def select_date(self):
    # click calendar
    self.js_click((By.XPATH, "//div[2]/button/i"))
    # send data 1
    self.driver.find_element(By.XPATH, "//span/div/input").send_keys("08112024")
    # send date 2
    self.driver.find_element(By.XPATH, "//span[2]/div/div/div/span/div/input").send_keys("1711024")
    # apply date
    self.wait_and_click((By.XPATH, "//button[2]/span"))



  def get_all_employee_names(self):
    """
    Gets all employee names by scrolling in small increments
    """
    try:
        scrollable_container = WebDriverWait(self.driver, 10).until(
            condition.presence_of_element_located((By.ID, "tableview-1022"))
        )
        
        all_names = set()
        scroll_position = 0
        scroll_increment = 600  
        prev_set_size = 0
        no_new_names_count = 0
        scroll_delay_seconds = 0.1
        
        while True:
            elements = self.driver.find_elements('xpath', "//*[starts-with(@id, 'employeeId_')]")
            current_names = {element.text.strip() for element in elements if element.text.strip()}
            
            # Add new names to our set
            all_names.update(current_names)
            
            # Check if we found any new names
            if prev_set_size == len(all_names):
                no_new_names_count += 1
                if no_new_names_count >= 6:  # no new names found in 6 attempts, at bottom.
                  break
            else:
              no_new_names_count = 0
              prev_set_size = len(all_names)
            
            scroll_position += scroll_increment
            
            self.driver.execute_script("""
                let element = arguments[0];
                element.scrollTop = arguments[1];
            """, scrollable_container, scroll_position)
            
            time.sleep(scroll_delay_seconds)  
            
            # Check if we've reached the bottom
            current_scroll = self.driver.execute_script("return arguments[0].scrollTop;", scrollable_container)
            scroll_height = self.driver.execute_script("return arguments[0].scrollHeight;", scrollable_container)
            visible_height = self.driver.execute_script("return arguments[0].clientHeight;", scrollable_container)
            
            # If we can't scroll further and we haven't found new names, we're done
            if current_scroll >= (scroll_height - visible_height) and no_new_names_count > 0:
              print("BREAKING CHECK")
              break

        name_list_size = len(list(all_names))
        print(f"List Size: {name_list_size}")
        return sorted(list(all_names))  # Return sorted list for consistency
        
    except Exception as e:
      print(f"Error while scrolling: {str(e)}")
      return []
        



  



tester = RosterSelenium()
user = "example@domain.com"
password = "xxxxxx"

tester.setup_driver()
tester.login(user, password)
tester.select_schedule_hyperfind()
tester.select_date()
employees = tester.get_all_employee_names()

print(employees)






